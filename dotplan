ROAD TO FINAL

# POI rendering
## √ Fixed screen scale
## √ Fixed size + rank scale
## Fixed rank size + zoom bump
-- markers can grow to twice their size when fully zoomed in (compensate for half of the zoom?)

# Region labelling
## Add POIs for all regions
## Two lines' worth of linebreak
## Fade out these when zooming in
## Send label types to zoom view

# Metal rewrite
# This is all of May...
## Render sprites
- For POIs

# LOD support
## Define reshape settings for LOD levels
## Run pipeline for each LOD level
--- push place distribution down below all tessellation
--- run tessellation in a loop
--- give ToolGeoRegion an array of tessellations at different LODs
--- push them into the chunk table under LOD key
## Suffix LOD to streaming key
## Use zoom to select LOD level
## Switch LOD level for entire map renderer
--- don't mix LOD levels in the same frame
## Don't swap render level while a LOD level is missing
--- separate the "wanted" LOD level from the rendered LOD level
--- when LOD request changes, pull in those chunks
--- don't switch rendering level until streamed goes still

# Spherical projection
## If at all possible?
## Otherwise, lock to Winkel-Tripel
--- Winkel-Tripel looks like a bastard to invert (for click mapping)

# Outline rendering
## Selection renderer generates outlines from known region "level""
-- pass to SelectionRenderer.select(...)
-- use to scale the miter ribs
## Pass width as uniform
-- ribs are already scaled to their normalized thickness
## Pass color based on rank
-- color should be set from SelectionRenderer.select too, directly on the render primitive
## Arc length UVs
-- arc length determined by lat/lon distance
## Scale outline width on tap
-- scale the outline width uniform with a progress variable
## Move outline generation to queue op

# Creative brief
## Shading
## UX
## Splash screen
## Launch experience
## Opening animation
## Selected state
## Color scheme
## Labelling scheme

# Persistence
## Store userstate to user defaults
## Store userstate to iCloud
## Knock out geoworld from userstate on startup

# Rendering improvements
## Outline feathering
-- can be done with an outline texture
## Texture UV's
-- can draw full-screen quad behind map? as a clear-op?
## 60Hz updates
-- setting on the viewcontroller
## Splash screen until streamer goes still
## Evict LRU render primitive
-- if memory used goes over high-water mark, evict 20% of the pool

# Content patches
## Move Gibraltar into Europe
## Nudge coastal cities

# √ Country collation
## Generalize variable names

## Tile streaming
*The world tree could be used to speed up loading.*
The structure of the world must be known up-front, but the actual
geometry data can be streamed in lazily.

Build a file header that stores offset/size of the worldtree and the geometry chunk.
Store the world quadtree (hashes + boxes) at the top of the file.
Store the actual GeoXRegions under their keys in a keyed container.

Goal 1: load the world tree without having to parse the geometry yet.
Goal 2: load specific GeoXRegions from their hashkeys
				- ah, that's not how Codable's hashkeys work. Pulling partial results doesn't make
				  sense, unless I want to spin up an entire Decoder, partially parse it,
				  copy out the parts I want, and then destroy the entire thing again.
				- I think a better approach is to marshal each XRegion into an NSData,
				  concatenate them into one superbuffer and build a ToC for it. Then
				  I can pull byte ranges out of the sbuffer and unmarshal them as needed.
				  Very parallelizable too.
				- Pulling these chunks needs to be run on a back thread, or there will be
				  terrible frame hitches. I think that, if the file is mmapped, I don't have
				  to go out on an I/O thread, but the parsing needs to be async.
				- Wrote a testbed for the above, works really well. The chunk table should be
				  seeded with the mmapped file, and then the targeted accesses will be spooled
				  up from disk by the OS.

That is, loading the world needs to be done from a streaming controller.

### Loading file chunks
Haven't done chunk loading in modern iOS for a long time, so here are primitives
for writing and loading a raw file header from a byte chunk.
```
var headerData = withUnsafePointer(to: header) { (headerBytes) in
	return Data(bytes: headerBytes, count: MemoryLayout<WorldHeader>.size)
}

var loadedHeader = headerData.withUnsafeBytes { (bytes) in
	return bytes.load(as: WorldHeader.self)
}
```

WOW this is actually looking super promising. The entire geometry chunk table is ~30MB now,
so I guess there must have been some massive redundancies in the Foundation-coded file.
Looked into Swift half-floats and there is a proposal making its way through the Swift WG
_this_ week.

Geometry streaming is in. Even without actually using the streamer (loading all the geometry
up-front anyway) loading times are down to about 70%.

---

$$ Move GeoRegion to /Mapping

Now for the final act: actually using the streamer.
- teach GeometryStreamer to load GeoTessellations on-demand
- teach GeometryStreamer to create RenderPrimitives for them
- let MapRenderer fetch primitives from GeoStreamer instead
-- list of hashes -> list of primitives
- GeoTessellations can be evicted when no longer useful
- move the 'updatePrimitives' logic to GeoStreamer
- parse on background thread
-- creating the GL objects can be done on main thread, because
	 that will be different on Metal anyway.
	 
This is working a lot better than it has any right to do.
The map renderer gets a set of region hashes to render, and does
just that. If a primitive is not resident, the streamer pulls it
in on a background thread and the renderer never knows it missed
anything since it gets the list through a compactMap.

And since we stream only what is visible through the quadtree,
I can zoom in on Spain, open Europe, and only get resident primitives
for Portugal, Spain, France and Italy. Norway isn't streamed in until
I scroll that way.

### Tile streaming strategy
- rebuild the world file
-- build a file header
-- store the quadtree at the top of the file
-- move the tessellations out to a separate dictionary
-- reference the tessellations by ownerHash
-- tree, geoWorld and tessellation dictionaries should be marshaled
   separately and appended into the file with the file header.

- load tessellations into a GeometryCache controller
-- render geometries via lookup into that cache
-- MapRenderer needs to lookup its primitives through the GeoCache
- at this point, everything should work as before

- replace the tessellation dictionary with the chunk table
- append the chunk table's data to the file
- on loading, create empty render primitives for each tessellation
- when a tessellation is looked up and isn't created yet, pull the chunk from
  the chunk table and update the empty primitive

---

- restructure the GeoRegions so they have keys to their geometries. the geometries should be kept separate in the tilestreamer and fetched from there.
- on boot, get a file handle on the geometry file, read the header, then the tree and the chunk table. They are always necessary and should be loaded up-front.
- from userState + worldTree, we can get the set of visible hashes. They will be all continents since we haven't updated with UserState yet.
- insert those GeoRegions into the GeoWorld??? or load the GeoWorld sans geometries directly? I guess that would be easier - keep the logic running as before, but just constructing the render primitives on the fly?
- yeah, looks like I can create a null VBO for the primitive, and then glBufferData into it when the actual vertices are available.

Find the continent hashes and pull them from file, load and render as normal.
Using .UserState, mark tree nodes as seen or not
From here on:
- when rendering the screen, figure out the visible set of hashes from the tree
- pull missing region geometries from file and create primitives on the fly
-- this can be done on a background thread until the main thread needs to create GL primitives
- build the primitive list based off opened & visible & available geometry hashes
- if a primitive is missing, just skip it - it will pop in when available

- move POI distribution job to runtime side
- load continent + country POI planes
- start client
- load region POI planes, distribute, re-render
- quantize world grid into 5ºx5º boxes
- if close to village-level, load POI box files for visible grids
- put into LRU cache
- evict tiles at memory pressure warning
- make sure model handles eviction of rendered tile

## POI Labeling
This is the feature that scares me the most right now, becaue I _don't_ want to end up having to render them through GL/Metal.
Instead, the idea is to put a transparent UIView on top of the render view, and put the labels on that.
That means that I have to be able to transform each visible POI to screenspace, along with its alpha.

1. Put transparent view on top of GLview, with a label rendering on it
2. Figure out the transform matrix from world- to screenspace
3. Create a view model to pass down the rendering pipeline from POI to label view
4. Possibly limit the label density in some way

Getting the set of visible POIs into the label renderer is ALSO tricky.
The Poi renderer will not be helpful, since it doesn't hold the POI:s' names,
and only holds them in batch planes. This'll require another copy of the data
(which will be a lot more efficient once box culling gets up and running).

So, init with the geoWorld, make the necessary starting data copy, and update as needed.
The data will be the entire regions this time around, since we need both the rich region
metadata and the rich POI meta.

## Map scale notes
At furthest zoom level, only capitals and mega cities (NY, Caracas, Mumbai, Stockholm, London, Berlin, Moscow, Lagos, Cape Town, Cairo, Tehran, Karachi)
At roughly Brazil size, large cities (Salvador, Rio, Palmas, Campo Grande, La Paz, Trujillo, Cordoba, Harare, Pretoria, Kansas City)
At roughly Colorado size, towns (Littleton, Soria, Guildford, Alingsås, Budaun)
At roughly Java size, villages (Magelang, Karangasem, Skara)

[1] = 1.0
[2] = 5.0
[5] = 25.0
[6] = 30.0

1 = 1
5 = 2
25 = 5
30 = 6

Very rough approx: Tr = 0.01z^2 + 0.3z

+ Levels get different border widths




Do the same vec2+scale trick I used for the outlines, for the POIs, to get consistent scales

Finally:
- per zoom frame, find any poi plane that moved across the rank threshold and touch its toggleTime


PROBLEM:
- how do I pack POIs into progressively deeper regions? Does a province contain its megacapital?
++ no problem, POIs are distributed into regions and promoted up into the countries

POI Scaling:
- Admin level <= 2 -> .Capital

### STEPS
+ rebake map data
- use rank to scale poi markers
- give indexedPrimitive an extra attrib buffer (scalar float)
-- fill that extra attrib from buildPlaceMarkers
- use zoom to reject pois
-- put rankZoom into Z coordinate
-- send stepZoom level as uniform to entire shader
-- #1 Reject if too distant
-- if sZ<rZ, reject
-- #2 Smoothfade on approach
-- if sZ>rZ-w, render with alpha = lerp through (sZ in rZ-w, rZ)
- polish crossfades from the poirenderer
-- stepZoom is zoom, smooth-snapped to specific rank levels

## View culling
Start designing the tile system now, otherwise the label rendering will go down the wrong path
Requirements:
- culling away render primitives that are clearly outside the view
- getting regions that intersect the view
- getting POIs that intersect the view
- making progressively good decisions at closer zoom levels
- fast insertion/removal
...which sounds like a perfect quadtree, with regions inserted in all t-cells they intersect.

In general: given a q-tree and a view box, query out the regions and POIs in the view box. Without
splitting the regions, regions may appear multiple times, but if we insert only the hashes, they can
form a set and the rest can be queried out of the map. This query would be "reject all cells that
don't intersect the viewbox."

...aaand if I only have the region hashes in the tree, then I can pull out the POIs from that too.

A) If the inner nodes of the search is included in the BSP result, then querying the map is easy
B) If we have a map from hash to region for all visible regions, then quering that is easy - and
   this would be super useful in other contexts.

Left to do:
- geoworld filter by region hashes (dictionary hash -> region, should be copy-on-write and cheap)
-- this dictionary should be the working copy after each opening
-- that is, geoWorld is the source data, and the dictionary is a userstate cache
-- worldTree should be renamed worldQuadTree, it's not the most important source
-- visibleRegions should be visibleRegionHashes, it's just the hashes of currently rendered regions
-- the new data source is availableRegions -> Int:GeoIdentifiable
--- IFF it is possible to still cast GeoIdentifiables to PlaceContainers and GeoTessellations
--- Because it it necessary to query against availableRegions and pull out poi lists and render primitives
--- after all this, MapRenderer doesn't have to do the tree traversal to init the renderPrimitives list!
- point query
-- spearfish quadtree nodes from worldTree.visibleHashes
-- use hashes to find regions in worldCache
-- get the tessellations from those regions
-- box-colline those tessellations
-- tri-collide those tessellations
- Poi cloud culling
-- for all visible hashes, find the regions in worldCache
-- collect all POIs
-- point-collide against the projected viewbox (project the viewbox instead of all POIs)
-- pass to POI renderer to select projected set
-- project those points into viewspace

## Map scale notes
At furthest zoom level, only capitals and mega cities (NY, Caracas, Mumbai, Stockholm, London, Berlin, Moscow, Lagos, Cape Town, Cairo, Tehran, Karachi)
At roughly Brazil size, large cities (Salvador, Rio, Palmas, Campo Grande, La Paz, Trujillo, Cordoba, Harare, Pretoria, Kansas City)
At roughly Colorado size, towns (Littleton, Soria, Guildford, Alingsås, Budaun)
At roughly Java size, villages (Magelang, Karangasem, Skara)

+ Levels get different border widths

## Outline rendering
- teach RenderPrimitive to work with different vertex formats
- try to break apart RenderPrimitive into Indexed, Arrayed and Tristrip versions
- try to create an outline primitive with Tristrip and fat vertex format

## POI rendering
- progressive POI plane rendering
-- each POI plane has a feature level
-- aggressive box culling
--- culled with its GeoRegion
-- each POI plane renders its alpha at relation to global zoom
--- country POI plane ramps in over 1.5x-1.6x; region POI plane ramps in over 3x-4x
--- this info and conf should sit in the POI renderer
-- POIs scale, but very slowly (~0.1x)

## Labels
- composite UIView over GLKView
-- transparent UIView (visual and touch)
-- render groups of labels based on
- alpha based on distance to label

## Dataset economy
- Swift bitfields?
- Fixed-point floats

## Persistence

## UI
- visited viewstate
- close regions
- interaction markers

## User journey
### Insights
- need a selection state separate from opening
-- which means "visited" and "opened" are two different states
- cities are used to navigate, especially at detailed levels
-- which means cities must be visible on any closed region

### First boot
U launches tapmap and is met by an overview of the world.
There is only land and sea. U taps the landmass. The borders around
the continents highlight, and the name "Earth" is displayed.
Also, a small circle appears, an inviting tap-to-select.
Tapping there, U marks Earth as visited.
?? How does the difference between selection and opening look?
U long-presses the landmass, and the cracks quickly spread out around U's finger.

When the cracks have spread to the edges of the landmass, it fractures
and reveals the continents underneath. The capitals of the world are marked
by little stars.

U has been to Europe, and taps it to mark it as visited.
U then long-presses Europe.
Europe splits apart to reveal the countries underneath.
The countries are labeled and tinted in their national
colours so they can be easily found.

At this point, U expects to be able to mark countries U has visited.
However, every opened country splits apart into their constituent regions.

The world fractures into a beautiful jagged mess of regions and
provinces, with names few have noticed. Gone is the "went to Germany",
and instead U went to Bavaria, Thüringen and Brandenburg.

### Covering U's travel history
U now starts going over past journeys. U keeps going through
Europe, drilling into countries. U leaves some of them marked
as visited but will come back later to sort out the provinces.

U makes a simple mistake by tapping Switzerland instead of Austria.
By tapping again, Switzerland is no longer marked as visited.
Had U also opened Switzerland, a simple pinch would have closed
Switzerland again, and closed all its cantons too.

Soon U reaches the less familiar region level. U is not sure whether the
visit to Bangkok means Samut Prakan or Samut Sakhon. By zooming in a bit,
cities are named by labels. U finds the Bangkok Metropolis area, and presses
the circle to mark it as visited.

### Making something from the data
U has marked and opened the parts of the world U has visited.
There is a button on the map, that flips it around to the backside.
On the backside is a wealth of presentation modes


